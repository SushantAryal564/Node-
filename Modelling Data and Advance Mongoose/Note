1. MongoDB Data Modelling
   Data Modelling:
   It is the process of taking the unstructure data generated by a real world scenario and then structured it into a logical data model in database which is done with certain criteria.
   Data modelling the part where we have to think the most and the most demanding part of building an entire application.
   Four step for data modelling:
   a. How to identify the different types of relationship between data.
   b. Referencing/ normalization vs. embedding/denormalization
   c. Embedding or referencing other document
   Whether we should embed document or reference document to other document based on different factor.
   d. Type of referencing

   Type of relationship between data
   1:1
   eg: 1 movie can have only one name
   Not so important

   1:Many
   These are the most important relationship.This can be distinguish into three type depending on relative amount.
   1:Few
   1 Movie can win many awards.
   1:Many
   1 Movie can have thousand review.
   1:Ton
   1 Movie can be watched by many people something that can grow to indefinite amount.
   In relational database there is just one to many without quantifying how much that many actually is. In MongoDB database though it is an extremely important difference as it is one of the factors that we are gonno use to denormalize or normalize data.

   Many:Many
   One Movie can have many actor at the same time one actor can act on many movies.

   Referencing vs. Embedding
   Each time we have two related dataset we can either represent that related data in reference or normalized form or in an embedded or denormalized form.
   Reference/Normalized: In reference or normalized we keep two dataset and all the documents seperated. In case of movie we could have one movie document, one actor document for each actor. so we create a reference with certain field or unique keys where movie key is parent key and actor key is an child referencing. In relational databases all data are represented in normalized form. There is an improvement in performance when we often need to query the related data on its own. We need 2 queries to get data from referenced document.

   Embedded/ Denormalized
   In no sequal database like mongoDB we can denormalize the data into a denormalized form simply be embeddin the related document right into the main document. If we denormalized the document we will have one main document containing all the main data as well as the related data. As a result of this our database will need to have fewer queries to the database because we can get the data at the same time which will increase our performance. Disadvantages are: we cannot query the embedded document on its own.

   When to embed and when to reference?
   Combine all 3 criteria to take decision:

   1. Relationship type (How two datasets are related to each other.)
      Embedding: 1:FEW, 1:MANY
      Referencing: 1:Many,1:Ton, Many:Many

   2. Data Access Patterns (How often data is read and written, Read/write ratio).
      Embedding:
      -Data is mostly read
      -Data doesn't change quickly
      -High read>write ratio: Only one trip to database per query. while for referencing we need two trips. If we embed a database that is read a lot in each query we save one trip to the database making entire process way more performant.

      Referencing:

      - Data is updated a lot
      - (Low read/write ratio)

   3. Data closeness (How much the data is related how we want to query the data).
      Embedding: Dataset really belong together. User+ email Address
      Referencing: We frequently need to query both dataset on their own.

There are no hard rule to model the data.
Type of Referencing:
a. Child Referencing: Here we basically keep references to the related child documents in a parent documents. They are generally stored in the array. The array could be very large if there are many ids this is an antipattern in MongoDB. Parents and children are very tightly coupled.
Use for: 1: Few relationship

b.Parent Referencing: In each child document we keep a reference to the parent element. In this case parent knows nothing about the children. Not who they are and not how many they are. They are more isolated and standalone.
use For: 1:Many, 1:Ton
One of the most important principle of MongoDb data modelling is that an array should never be allowed to grow indefinitely in order to never break that 16 megabyte limit.We don't want to sent the user containg millions of Id each time for request to parent dataset.

c. Two Way referencing:
User for: Many to Many relationship
It is an combination of child referencing and parent referencing. so both the parent and child document could be easily queried.

Summery:
-The most important principle is: Structure your data to match the ways that your application queries and update data.

- In other words: Identify the question that arises from your application use cases first, and then model your data so that the question can get answered in the most efficient way.
- In general always favor embedding, unless there is a good reason not to embed. Espicially on 1:FEW and 1:Many relationsip.
- A 1:Ton or Many:Many relationship is usually a good reason to reference instead of embedding.
- Favor referencing when data is updated a lot and if you need to frequently access a dataset on its own.
- Embedding when data is mostly read but rarely updated, when two dataset belongs intrinsically together.
- Don't allows array to grow indefinitely. Therefore if you need to normalize use child referencing for 1: many relationship and parent referencing for 1:Ton relatioship.
- Use two way referencing for Many-Many relationship.

3. Designing Our Data Model

4. Modelling Locations (Geospatial Data)
   MongoDB supports geospatial data out of the box. Geospatial data are data that describe the place on the earth using longitude and latitude coordinates. We can describe simple points or we can describe complex points like lines or even polygon or even multi polygons.
   MongoDB uses the special data format for geosptal data called GeoJSON.
   In order the specify that the object is an geoJSON we need type and coordinate property.
   startLocation: {
   //This object isn't to specify the schema type this object is an embedded object.
   // GeoJSON
   type:{
   type:String,
   default: "Point" ,// it can be polygon or line default one is point.
   enum: ["point"],
   },
   coordinates:[Number] // Array of Number coordinate of number in longitue and latitude format.
   },
   In order to specify the geospatial data with mongoDb we basically need to create a new object it need to have at least two property type and coordinates other field can also be added.
   Here startLocation isn't a document itself, it is basically an object describing a certain point on earth. In order to create an document and embbed them into another document we need to create an array. We always need to use the array and by specifying array of objects this will then create brand new documents inside of the parent documents.

5. Modelling Tour Guide Embedding
   When creating a new document the user will simply add arrays of an ID and we will then get the corresponding document based on id and add them to parent document.
   It only work for creating a new document but doesn't work for updating the new document. To update the doucment we have to implement the same logic.

6. Modelling Tour Guides Child Referencing
   In case of Referencing we need to have and array which consists of object with key type with value mongoose.Schema.Object and ref with value the Model name.

7. Populating the Tour Guides
   Populate to get access to the referenced tour guides whenever we query for a certain tour. We use populate in order to basically replace the fields that we referenced with the actual related data and the result is as if the data has always been embedded when the data is in completely different collection.
   Behind the scence using populate will actually create a new query, so this might affect our performance. Hugh effect in large application.

8. Modelling Reviews Parent Referencing
   f
