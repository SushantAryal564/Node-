1. MongoDB Data Modelling
   Data Modelling:
   It is the process of taking the unstructure data generated by a real world scenario and then structured it into a logical data model in database which is done with certain criteria.
   Data modelling the part where we have to think the most and the most demanding part of building an entire application.
   Four step for data modelling:
   a. How to identify the different types of relationship between data.
   b. Referencing/ normalization vs. embedding/denormalization
   c. Embedding or referencing other document
   Whether we should embed document or reference document to other document based on different factor.
   d. Type of referencing

   Type of relationship between data
   1:1
   eg: 1 movie can have only one name
   Not so important

   1:Many
   These are the most important relationship.This can be distinguish into three type depending on relative amount.
   1:Few
   1 Movie can win many awards.
   1:Many
   1 Movie can have thousand review.
   1:Ton
   1 Movie can be watched by many people something that can grow to indefinite amount.
   In relational database there is just one to many without quantifying how much that many actually is. In MongoDB database though it is an extremely important difference as it is one of the factors that we are gonno use to denormalize or normalize data.

   Many:Many
   One Movie can have many actor at the same time one actor can act on many movies.

   Referencing vs. Embedding
   Each time we have two related dataset we can either represent that related data in reference or normalized form or in an embedded or denormalized form.
   Reference/Normalized: In reference or normalized we keep two dataset and all the documents seperated. In case of movie we could have one movie document, one actor document for each actor. so we create a reference with certain field or unique keys where movie key is parent key and actor key is an child referencing. In relational databases all data are represented in normalized form. There is an improvement in performance when we often need to query the related data on its own. We need 2 queries to get data from referenced document.

   Embedded/ Denormalized
   In no sequal database like mongoDB we can denormalize the data into a denormalized form simply be embeddin the related document right into the main document. If we denormalized the document we will have one main document containing all the main data as well as the related data. As a result of this our database will need to have fewer queries to the database because we can get the data at the same time which will increase our performance. Disadvantages are: we cannot query the embedded document on its own.

   When to embed and when to reference?
   Combine all 3 criteria to take decision:

   1. Relationship type (How two datasets are related to each other.)
      Embedding: 1:FEW, 1:MANY
      Referencing: 1:Many,1:Ton, Many:Many

   2. Data Access Patterns (How often data is read and written, Read/write ratio).
      Embedding:
      -Data is mostly read
      -Data doesn't change quickly
      -High read>write ratio: Only one trip to database per query. while for referencing we need two trips. If we embed a database that is read a lot in each query we save one trip to the database making entire process way more performant.

      Referencing:

      - Data is updated a lot
      - (Low read/write ratio)

   3. Data closeness (How much the data is related how we want to query the data).
      Embedding: Dataset really belong together. User+ email Address
      Referencing: We frequently need to query both dataset on their own.

There are no hard rule to model the data.
Type of Referencing:
a. Child Referencing: Here we basically keep references to the related child documents in a parent documents. They are generally stored in the array. The array could be very large if there are many ids this is an antipattern in MongoDB. Parents and children are very tightly coupled.
Use for: 1: Few relationship

b.Parent Referencing: In each child document we keep a reference to the parent element. In this case parent knows nothing about the children. Not who they are and not how many they are. They are more isolated and standalone.
use For: 1:Many, 1:Ton
One of the most important principle of MongoDb data modelling is that an array should never be allowed to grow indefinitely in order to never break that 16 megabyte limit.We don't want to sent the user containg millions of Id each time for request to parent dataset.

c. Two Way referencing:
User for: Many to Many relationship
It is an combination of child referencing and parent referencing. so both the parent and child document could be easily queried.

Summery:
-The most important principle is: Structure your data to match the ways that your application queries and update data.

- In other words: Identify the question that arises from your application use cases first, and then model your data so that the question can get answered in the most efficient way.
- In general always favor embedding, unless there is a good reason not to embed. Espicially on 1:FEW and 1:Many relationsip.
- A 1:Ton or Many:Many relationship is usually a good reason to reference instead of embedding.
- Favor referencing when data is updated a lot and if you need to frequently access a dataset on its own.
- Embedding when data is mostly read but rarely updated, when two dataset belongs intrinsically together.
- Don't allows array to grow indefinitely. Therefore if you need to normalize use child referencing for 1: many relationship and parent referencing for 1:Ton relatioship.
- Use two way referencing for Many-Many relationship.

3. Designing Our Data Model

4. Modelling Locations (Geospatial Data)
   MongoDB supports geospatial data out of the box. Geospatial data are data that describe the place on the earth using longitude and latitude coordinates. We can describe simple points or we can describe complex points like lines or even polygon or even multi polygons.
   MongoDB uses the special data format for geosptal data called GeoJSON.
   In order the specify that the object is an geoJSON we need type and coordinate property.
   startLocation: {
   //This object isn't to specify the schema type this object is an embedded object.
   // GeoJSON
   type:{
   type:String,
   default: "Point" ,// it can be polygon or line default one is point.
   enum: ["point"],
   },
   coordinates:[Number] // Array of Number coordinate of number in longitue and latitude format.
   },
   In order to specify the geospatial data with mongoDb we basically need to create a new object it need to have at least two property type and coordinates other field can also be added.
   Here startLocation isn't a document itself, it is basically an object describing a certain point on earth. In order to create an document and embbed them into another document we need to create an array. We always need to use the array and by specifying array of objects this will then create brand new documents inside of the parent documents.

5. Modelling Tour Guide Embedding
   When creating a new document the user will simply add arrays of an ID and we will then get the corresponding document based on id and add them to parent document.
   It only work for creating a new document but doesn't work for updating the new document. To update the doucment we have to implement the same logic.

6. Modelling Tour Guides Child Referencing
   In case of Referencing we need to have and array which consists of object with key type with value mongoose.Schema.Object and ref with value the Model name.

7. Populating the Tour Guides
   Populate to get access to the referenced tour guides whenever we query for a certain tour. We use populate in order to basically replace the fields that we referenced with the actual related data and the result is as if the data has always been embedded when the data is in completely different collection.
   Behind the scence using populate will actually create a new query, so this might affect our performance. Hugh effect in large application.

8. Modelling Reviews Parent Referencing

9. Virtual Populate Tours and Reviews
   In the case of parent referencing we aren't able to access the child document from the parent document as parent doesn't really know about its children. solutions for this problems are:
   -Child referenicng an array of child document id in the parent document.
   -(Recommended ) Virtual populated: With virtual populate we can populate the parent with child document without keeping the array's of ID's on the parent document without persisting in to the databse.

10. Implementing Simple Nested Routes
    Nested Routes: Is to access the child resources from the parent resources.
11.
12.
13. Nested Routes with Express
    Merge params
14. Building Handler Factory Functions Delete
    Adding very similar handler to all of our controllers will create a lots of duplicated code. If we wanted to change some http status code or status message then we have to go into each and every controller and change the handler in there so we can create a factory function instead of writing the code manually. Factory function is a function that returns another function.
    Closure: Inner function will get access to the variable of the outer function even after the outer has already returned.
15.
16.
17.
18. Adding a me endpoint
19.
20.
21. Improving Read performance with indexes
    While querying for data in an document it will be relatively faster for document with less but as the data increases so the processing time. So indexing could solve this problem. MongoDB automatically creates an index on the ID field by default. Here ID index is an ordered list of all the ids that get stored somewhere outside of the collection. This index is very useful because whenever the document is queried by ID MongoDB will search that ordered index instead of searching from whole collection and looking at all the documents one by one.
    We can set our own indexes on fields that we query very often.
    With index we don't have to scan through all of the documents which is a hugh performance gain.
    Mongoose behind the scence in order to ensure the uniquness of the field create a unique index.
    simple index: One with one field.
    compound index: One with two or more fields. When we create a compound index we don't need to create one individual for each of the fields.
    Indexes that we create to search the documents take up a lots more space then the document themself.
    How do we decide which field we actually need to index?
    We need to carfully study the access pattern of the application in order to figure out which field are quired the most and set the indexes for these fields. We don't want to index for each field blindly as each index actually uses resources and each index needs to be updated each times the underlying collection is updated. If we have a collection with high read write then it would make absolutely no sense to create an index on any field in this collections because the cost of updating the indexes and keeping it in the memory outweight the benefits of having index. We should always balance the frequency of queries using that exact field with the cost of maintaining the index and also the read write pattern of the resources.

22. Calculating Average Rating on Tours
    Storing the summary of the related data set on the main dataset is actually a very popular technique in mongoose.
    Static Method: It is one of the feature of the Mongoose.
    Instance Mehthod: These are the method that we can call on the documents.
    Post Middleware doesn't get access to next so we cannot use it.

23. Calculating Average Rating on Tours
    A bit complex need revision and throughly learning in this topic. Error in code also don't know how to debug it.

24. Geospatial Queries Finding Tours within Radius
    Radius should always be in radian which is obtain by dividing the distance by the radius of the earth.
    In order to do basic geospatial queries we need to first attribute an index to the field where the geosptaial data that we are searching is stored.
    tourSchema.index({startLocation: }) For geospatial data this index needs to be a 2D sphere index if the data describe real points on Earth like sphere.

25. Geospatial Aggregation Calculting Distance
    For geospatial aggregation we have only one single stage called geonear. It always need to be the first stage. It requires that at least one of our fields contains a geospatial index. If we have a multiple field with the geospatial indexes then we need to use the keys parameter in order to define the field that we want to use for calculation.
