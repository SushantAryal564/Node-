3. What is Mongoose?
   Mongoose is an object Data Modeling library for mongodb and node.js a higher level of abstraction. Express is an layer of abstraction over node.js whereas mongoose is an layer of abstraction over mongodb.
   object Data Modeling library is a way for us to write javascript code that will then interact with database.
   Mongooose give us lot more functionality out of the box allow for rapid and simple develoddpment of mongoDB databse interactions.
   Features: Schemas to model data and relationship, easy data validation, simple query API, middleware etc.
   Mongoose schema: Where we model our data, by describing the structure of the data, default values and validation.
   Mongoose Model: a wrapper for the schema, providing an interface to the database for CRUD operations.

4. Creating a simple Tour Model
   MOngoose is all about model which is like a blueprint we use to create documents. It is like a classes in the javascript from which we create object out of them.
   We create a model in mongoose in order to create document using it, and also to query update and delete these documents. To perform each of the CRUD operation we need a MONGOOSE model. We create a model from the mongoose schema.
   creating a new Schema in mongoose:
   const tourSchema = new mongoose.Schema({
   name:String,
   rating:Number,
   price:Number,
   })

5. Intro to Back end architecture MVC, Types of Logic and More
   MVC(Model View Controller) where:
   Model: Business Logic (Concerned with application data and bussiness logic)
   Controller: Application Logic (The function of controller is to handle the application request interact with model and send back response to client.)
   View: Presentation Logic (If we have graphical interface in app.)
   using this architecture allow us to write modular appliation which is more easier to model or scale.
   One of the major role of MVC is to seperate Application logic and Business Logic.
   Application Logic:
   Code that is only concerned about the application's implementation not the underlying business problem.
   concerned about managing request and response.
   About the app's more technical aspects.
   Bridge between model and view layers.

   Business Logic
   Code that actually solves the business problem we set out to solve.
   Directly related to business rules, how the business works and business needs.
   Examples:
   creating new tours in database.
   Checking if user's password is correct.
   Validating user input data.
   Ensuring only user who bought a tour can review it.

   We must be sure that our application logic is in Controller where as our business logic in the model.
   Fat model/ thin controller: Offload as much logic as possible into the models, adn keep the controllers as simple and lean as possible.

6. Another Way of Creating Documents
   exports.createTour = async(req,res)=>{
    <!-- const newTour = new tour({});
    newTour.save(); -->

   We can use Tour model directly as well and call the create method on it into that function we pass the data that we want to store in the databse as a new tour.
   If the field are not in the schema they aren't put in the database. Everthing that are not in schema aren't put in the database.

7. Reading Documents

8. Updating Documents
   Model.prototype.save() which means an object created from the class. save method is called on the document.

9. Modelling the Tours
   summery:{
   type: String,
   trim: true,
   }
   trim removes the white space at beginning and the end of the document.

10. Making the API Better Filtering
    In mongoose we have two way to write a database query.
    The first one is to use filter object.
    the second way is special mongoose method.
    We could have other functionality like sort for sorting functionality, page for pagination so we need to make sure we aren't querying for these in our database cause we want to use it only to implement pagination not to query in database so we need to exclude this special query string before we can do filtering.
    const query = Tour.find(queryObj);
    Here find method return an query.But as soon as we await the query will then execute and come back with an document that match our query. so we cannto implement sorting and pagination and other feature. so we need to save it as a query.
    const tours = await query;
